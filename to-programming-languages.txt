# the opinions of great programmers

## Zeta's opinion

Zeta has written: a *very good* game engine, and is now writing an ARM assembler, and a simple OS

Java is bad
C# is like Java owned but by Microsoft, and thus doubly bad

C is good
Haxe is very good
Rust is great



# really good reads

https://ziglang.org/learn/why_zig_rust_d_cpp/




# what langauge is best for my needs?

## my needs (or wants?)

it should be "high-level" (specifically, not forced to handle pointers, references, and const), preferrably wiith many cool contemporary features
it should be relatively fast (at least faster than ruby and python interpreters)

for simple fun OS shell and web server hackery: :D
  - it should have an interpreter, so that you can just run it via cli （for example： user/bin/[language] for bash）
  - it should be able to run on both server-side and client-side (both: interpreter or compiled, for simple scripts and complex games/apps)
  
for games (and other "creative" applications that use various input/output hardwares): :D
  - it should have the option of memory management, for fine-tuning intense memory changes--textures going in 'n out--yet i should'nt be forced to handle memory, thus
    - it should have automatic garbage collection (pass by reference), yet 
    - it should allow the option to write "unmanaged code" *and/or* make it very easy to interop with C/C++ so that you can just write C/C++ modules when needed *(note: nearly all langauges allow this..)*
  - it should be designed to be cross-platform, or at least have that in mind
    - compile to C (for most platforms: desktop OSs, iOS (+ iPadOS), consoles, embedded devices, etc.)
    - maintain a set of libraries for target platforms: iOS > desktop OSs > consoles > the rest, in that order
    x/- compile to Java for Andriod (i personally don't care about this platform... non-iOS mobile devices are a mess)
  
  
## answers and some thoughts

### the cross-platform problem
as far as i know, only Haxe (indie), C# (Microsoft), Dart (Google), and C++/C fit all of the above requirements above. The need for cross-platform "target" compilers and standard libs really narrow down the choices, as most newer languages just won't have neither the library nor compilers, *yet*, they have the potential, as long as they can compile down to C. It's really up to the people, including big corporations, to build them up, along with building various frameworks using them, and then to maintain them... Only time will tell. Beyond Haxe, C#, and Dart though, i haven't really seen many good cross-platform libraries... (*todo: I'd have to look into the C# and Haxe FFI like, is it easy to just call a C# function that calls the native (C/C++/obj-C) iOS function for "share"? If so, then *that's major*, for me, a game-breaker, really. Otherwise, you'd have to maintain an entire set of iOS bindings, and bindings for every platform!*)

see ["app frameworks.txt"]

see ["game frameworks.txt"]

as far as using C# as a scripting language, well, there's the Rosyln compiler (part of open-source .NET foundation) and "cs script", but i'd have to look into it some more.. but **if you can script in C#, then, well, it might just be game over for any other language!**

**nearly all high-level languages interop with C, so, i see no reason to write an *entire* program in C or C++_--or even Rust!_**, leave that to the game-engine makers, and **anyway, you can always write C/C++ for the intensive sections when needed** (i doubt i'll ever need to). *I don't want to even think about pointers or references, and definitely not smart pointers! :barf:* Java is the lowest i'd stoop.
  - writing the core in C/C++ is perhaps the best option, as you get the best of both worlds: manual memory management for the core, and a light-weight scripting langauge on top (Lua, Wren), or, people can create high-level bindings in their favorite langauge of choice

as long as the language can compile to C/C++, then it should, in theory, work with just about any device (desktop, mobile, embedded, whatever). The problem is that it'll have to link to the libraries that the platform uses, which is likely C/C++/obj-C (exception: Android uses Java).


## libraries matter
libraries, including frameworks, engines, matter. Altough you could use just about any language to solve just about any solution, certain languages are better suited for certain... *areas* in programming. This occurs naturally: someone wants to make something, solve something, they *hopefully* try to choose the right tool for the right job: the right language. Thus, the **language is just a tool** to do a job.

Over time, people who use the language will create libraries, *hopefully* many of which are open-source, thus buidling up a huge collection libraries specific to that language. **That resulting library, the contents of the library, is really an effect of the language itself, along with the community behind it, it's pop frameworks, etc.** If the language was created for intense math, then intense math libraries will likely be the result. (todo: If the language is close to being natural, like a human language, then it will likely be popular (Python). If the language has particular traits to it, or a style, such as focusing on being neat, tidy, and *clean* (Ruby), then it might have a community following...)

(back to libraries...)
Languages often have their own package managers: haxelib for Haxe, RubyGems for Ruby, NuGet for C#. Just by looking at the package manger, you can get a pretty good idea of what that language is mostly used for, and the power of the big frameworks in it. So, in RubyGems, the Rails web framework is a huge force, and much of Ruby is indeed used for web dev, along with general scripting / cli. In Haxelib, game 'n app frameworks such as OpenFL and NME are by far the biggest forces, with game frameworks and game-related libraries following after. todo: check out NuGet. But anyway, i think checking what's in the packagee manage, in the library, is a good way to compare languages, instead of comparing the features of the language itself, as it's the people that make the languages, not vice versa.



# important changes in dev tech

## WebGL is dead. Long live native dev.
with WebAssembly now, can just skip the whole HTML5/WebGL crap and basically run native apps (machine code?) in the web-browser :o :O luckily, i've never cared about web-targets, but now it's finally really dead! :) No Flash. No HTML5/WebGl. *Long live native dev.*

## Microsoft <3 games *and* now open-source too?
.NET *Core* is like a whole new revamped open-source cross-platform beast. In the past, Microsoft/.NET was tied to Windows, and so *the people* created Mono as an open-source cross-platform version of .NET, but now, the new .NET Core can truly be used to make *everything*! (I guess Mono is dead..? Or maybe it was used as a base for .NET Core??) *The C#/.NET stock is rising...* Thus, app frameworks like **Avalonia** and **Uno** can compete with Google's Flutter, and the game frameworks like **Unity** and **MonoGame** (based on Microsoft's own XNA framework used in the original Xbox) are still respectively the *the kings of indie game engines*. Microsoft is doing well. All of that, alongside open-source-made VS Code, and the fact that Windows always had a monopolty on games. Microsoft has always been closer to games than both Google and Apple have ever have been, and now it's really showing.





# compare languages by reading them

https://learnxinyminutes.com/

good examples:
aim for 2d space shooter classes

todo:
crystal
scala
haxe

ruby
  - https://github.com/benbalter/jekyll-optional-front-matter/blob/main/lib/jekyll-optional-front-matter/generator.rb

rust
  - https://github.com/rsaihe/zenith/tree/main/src/game
  - https://github.com/naodroid/bevy_game_tutorial
  
OCaml
  - https://github.com/HaxeFoundation/haxe/blob/development/src/core/tOther.ml
    - brain-exploding example of Haxe's compiler



historical intrigues:
BASIC (well, some variant of it):
  - https://github.com/wls/Wumpus.bci/blob/master/wumpus.bci
    - 'let' keyword for dynamic types?? :o
  - surprisingly simple and readable, almost like it was specificalyl made for game programming! :o 
  - lots of GOTOs
  - many people cite this an their first prgramming language as a child
  
Commodore64 (c64)
  - https://github.com/lvcabral/retaliate64/blob/master/source/gameData.asm
  - everything is a "co-routine"
  - feels closer to assembly, three-letter terse commands
  




# my choices

Haxe in general, garbage collected
Ruby, scripting
C vs Rust vs Zig vs Odin, manual memory management





# a few contemporary languages, old and new

order of traits:
simple summary
frameworks
the rest


## old classics
*Haxe**
  - simple, *light-feeling*--feels like a scripting language!, **powerful like C#**, but without all the *heaviness* of it, **feeling more like Ruby**, just *siiiick*, **garbage collector depends on the target**
  - frameworks include: NME, Heaps, OpenFL (now feels like it's stuck woth too much Flash baggage..), HaxeFlixel, HaxePunk, Kha; all of them are basically an i/o base **to create basically *anything*, cross-platform**. In addition, there's HaxeUI, coconut, and bindings for React and React Native for cross-platform UI, along with bindings for other stuff, like RayLib and Unreal.
  - like C#, it has many contemporary features: anonymous functions, local functions, ADTs, properties, etc. and even a macro system (not sure if C# has this...), but it's not nearly as exhaustive as C#, making it more tolerable for a mortal, and a little less flexible, which can actually be good, as you can focus more on writing as opposed to thinking which C# feature to use here, and making code easier to read too (try reading the code of a pro C# user!)
    - also has **macros** that are much more powerful than anything C# has
    - also like Ruby, it feels very *Linux-y*, where **everything is a simple text file**, including the build file (this is a major difference in feeling to C#, as it can feel like you must edit stuff in VS's gui, or even Unity's gui. In Haxe, **everything can be done by simple text editing**, no gui software necessary)
  - maybe the first major language with **cross-platform** in mind?
  - has all of the features of ruby (container filters, anonymous functions, etc.) plus more, but comes with a *much much* faster compiler, making Ruby feel rather obsolete, and just surviving off of it's libraries and community
  - **_incredible_ compilation options: compile to nearly any other language (including C, which can then be compiled again by optmized-compiler LLVM to reach near-C speeds, or to use C libraries, or to build in C for iOS/consoles/embedded devices, and javascript, to be run in a browser or to use pop javascript libraries or to compile to Node.js, and Java, to build for Android, and to bytecode which is then run by a VM (Neko [old VM?], HashLink [current VM]), itself with two options: HL/JIT and HL/C**, one for faster compilation speed and one for optimized run-time speed *whoa...*
  - has **a standard cross-platform library** that all newer languages try to copy
  - don't feel overwhelmed by decades of C/C++ libraries to piece together, nor have to think about pointers/references/smart-pointers and header files
  - don't feel like one has to conform to the ways of Microsoft and the .NET framework: you can write your code in any way you want to, and use any tools you want to too! :)
  - small community feeling, will run into the makers on the forums, discord, or github (including the maker of Haxe/Heaps himself!!), can make a big difference :) but **the con of this is that there's simply not enough community power, so resources are scarce, web-site (including tutorial, book) and package manager are rather out-dated, etc.**
  - frameworks like OpenFL, NME, Heaps ensures it's shared cross-platform code is in good condition, though not .NET level
  - haxelib package manager
  - **my fav :)**

**C#**
  - mighty mighty C#... along with it's .NET framework and Visual Studio, is really tough to beat
  - has great frameworks for both games (Unity, MonoGame) and cross-platform apps (Avalonia, Uno, ASP.NET?)
    - and as long as these frameworks exist, it's cross-platform libraries will be in top-notch condition
    - probably also used by Microsoft themselves for making Xbox games
  - *incredible feature-set* for the language, the standard library (System, IO, etc.), and the .NET library
    - basically C# v3 (in 2007) set the standards for high-level languages with lambda expressions, anonymous functions, and LINQ via .NET, etc. (during my first programming job!), and didn't add much until v7 (in 2017) when it added pattern matching, tuples, local functions, etc., but that's okay as they are working on all three things: a lanauge, a library, and a tool-set. By C# v10 now, the features are *overwhelming!*. There's really nothing to complain about here.
  - always had a compiled approach instead of scripting, making it less popular in the web-dev world, which made it even better, as it keeps the serious native big game/app devs away from the horrendous temporal javascript/electron/html5 web-dev world
  - Microsoft, and very much *feels* like Microsoft: *heavy*, heavy dev environment, heavy libraries, clunky standard coding convention, etc.
  - after using this, it feels like there's really no reason to use anything else! (todo: :thinking:)
  - has a contemporary **scripting** solutions!!?? :o :O
    - Rosylyn compilerm, csscript, dotnet-script
    - **todo: with this, there's not much reason for even Haxe, then is there?...** :thinking:
  - https://www.nuget.org/packages/MonoGame.Framework.WpfInterop/ - LOL, amazing! WPF UI with MonoGame behind it
  - nuget package library
  
**Ruby**
  - a scripting language that people seem to really *love*
  - the frameworks 'n libraries seem to be more web-dev-oriented, mostly thanks to Rails, the language's premier web framework.., but also Jekyll (used by GitHub Pages), Sinatra (*this one looks amazing...*), Hinami, Middlemen (*this looks like a good step up from Jekyll*), and more..
    - there are two particular newer frameworks that compile to machine language, DragonRuby and RubyMotion, for cross-platform game and apps, deploying to just about any device! :o It sounds like haxe's frameworks! Unfortunately, they are closed-source, giving it a more closed-off, isolated feeling, and they cost quite a chunk of money to try...
  - aims to be natural, like English;
    - also_uses_snake_case_convention :o *finally*, someone gets it! although, maybe-i-like-this-better
    - uses function-name? for functions that return true/false *neat!*
  - *very clean* syntax
    - uses the last statement's expression in a function as the return value, thus saving a line; and oh you can easily write one-liner functions with Ruby! :o
    - can omit the '()' in function()
    - no need for 'var'
  - seems to have a *quirky*, more diverse, rad community vibe, similar to Haxe :), but perhaps more accessible and diverse, whereas Haxe attracts just game-makers
  - *very* object-oriented, even in the language itself! (maybe C# got that idea from here..), allowing you to even hack away at the language itself! you can even add methods to the main parent Object that everything inherits!! :o *everything is an object*
  - **too slow for games, unless it has a compiler? :(**
    - maybe even too slow for big apps :/ (compare: Jekyll vs Go)
  - adds a ton of features: object.map => { anonymous function / lambda / closure / "block" (i dunno difference) }, container.select/find/filter {|item| item == item_i_want}, getter/setters, modules (this is interesting and have not seen before: basically can include group of methods to an object! :o), etc.
  - has incredible syntax: no var necessary?
  - see this for major differences: https://www.ruby-lang.org/en/documentation/ruby-from-other-languages/
  - game engines, such as Gosu, are written in C/C++ and then wrapped/binded by Ruby, because it would be too slow otherwise
  - Ruby Gems package manager
  - although i missed this generation, i think i would have enjoyed this little world :)
  - **my fav scripting language**
  
Scala
  - basically a replacement for Java, interops with Java, compiles down to Java bytecode (to go into JVM)
  - much loved
  - just as featureful and powerful as most of the newer contemporary lanugages
  
Python
  - perhaps the most popular and most loved scripting language, even as of 2022(!!), competitive to Ruby
  - frameworks and libraries seems to be more scientific-oriented, with machine learning, ai, math, 'n so on
  - can't go wrong with using this as a scripting langauge, however, it's rather slow for intense things like games, with only a rather recent C implementation helping it; around as slow as ruby, and without the rad features and rad community
  - Google, although, even they probably rewrote a lot of stuff in Go
  
Java
  - C/C++ power without memory management, a classic systems language (along with C/C++) but *much* easier to use
  - frameworks include: LibGDX... (todo: ??)
  - the vibe i get is strange... there seems to be only an old cult that like it, similar to neovim's cult
  - **compiles to bytecode that is then processed by VM that must be installed on the target device, whereas C/C++ directly accesses memory**
  - **adds a garbage collector, making it feel "high-level"**
    - but no pointers *at all*, **all objects are references and all objects are passed by references** (basically every high-level language after this does this)
      - thus perhaps making fine-tuning of memory impossible?
    - a good comparison between C++'s pointers and Java's magic
      - https://stackoverflow.com/questions/1750106/how-can-i-use-pointers-in-java#1750197
  - feels neat, like an early C#! :)
    - although the modules/class seem like 5 folder deep??
  - no header files? :o
  - object-oriented, direct contender to C++
  - adds lambdas (maybe this was added later on..)
  - can interop with C through JNI (java native interface)
  - this is a world i've seem to have avoided, just out of taste... i think this is because when i started, it just didn't have a good IDE compared to C++'s Visual Studio; i had to use Eclipse, which was garbage that unfortunately couldn't be collected :/  
    - however, now looking at it again, it's strange that this isn't used more! It looks like a much neater version of C++, like a pre-cursor to C#

C++
  - frameworks: ??, maybe C++ people don't rely on frameworks: they build it! :p
  - manual memory management via pointers 'n references 'n "smart" pointers 'n the const key-word
    - and therefore pass function arguments by value or pointer or reference or smart pointer too
  - adds **object-oriented design features (classes)** to C
    - also adds the idea of allocating stuff during constructor and de-allocating during deconstructor
  - adds references to C (i guess in C you just had to use pointers for everything..?)
  - smart pointers (3 kinds) that generally delete themselves once the last reference falls out of scope
    - this just makes it even more complex!! :( why worry about references and 3 kinds of smart pointers and raw pointers, when you can worry about raw pointers?
  - header files are also annoying
  - adds "standard library" including strings to C (before they were an array of "char"s)
  - adds generics ("templates"), enums, and other now basic features..
  - loved/hated, mostly hated, i think
  - strange development cycle, wherein cults choose which version they prefer the most (C++14, C++20, etc.)
  - also a problem of multiple compilers, each of which only work for certain version or certain features?? (gcc, vs, dev-cpp, etc.)
  - this first reddit thread illustrates the terrible flaws of C++
    - https://www.reddit.com/r/rust/comments/4yz59h/cc_interop/
  
C
 - **a *very* simple "low-level" language used by most electronic devices**
 - frameworks: RayLib, (todo: ??), not really the best for making frameworks, as it's not object-oriented; it'll more or less end up like RayLib: a ton of functions included in the top-level namespace, as there is no concept of namespace!
 - manual memory management via "raw" pointers (no references?) and the const key-word
 - *not* **object-oriented**
   - and interestingly, it forces you to write in a simple, top-to-bottom way, making programs, even if it's just a giant single file, rather easy to read, as opposed to being forced to create a ton of "objects", most of which don't make sense. With less freedom and more constraint, you are able to do what is needed without thinking about how to do it. There's a whole philosophy about this vocalized by Casey Muratori and his hand-made network. And indeed, it makes C libraries much easier to follow along than C++ libraries:
 - has header files, which is annoying, but it seems nowadays people just write everything in the header file!
 - Raylib is quite beautiful: simple, straight-forward, because there's really no other way to do it
 - OpenFrameworks also has Raylib's beauty (not sure if it's C or C++ tho..)
 - now, i'm not sure if i'd want to write a game in that style, *i loved FlashPunk!, i love my objects! ;(*, but i sorta see why straight up simple C results in very good code, dividing data from functions, ending up to be more modular, more re-usable, and most importantly, easy to follow


## newer stuff
**Zig**
  - from the site:
    - No hidden control flow
    - No hidden allocations
    - First-class support for no standard library
    - A Portable Language for Libraries
    - A Package Manager and Build System for Existing Projects
    - Simplicity
    - Tooling
  - great simple web-site 'n documentation
  - this looks great! no hidden bullshit. optional std lib. everything about it makes sense to me! :)
  
  
Odin
  - from the hand-made network
  - like C, not object-oriented, with a belief that *data and procedures should be seperate, and that behaviors shouldn't even exist!* :o very rad
  - influenced by Go


Pony
  - lol, i like this idea, extremely statically typed, so that it's never a question, no concept of memory management
  

**Crystal**
  - like a compiled and static-typed ruby, along with *much* faster, in fact, **at C++ speeds!?!?** :o :O
  - sytax and style *very very* similar to ruby, like 75% similar!
  - deeply **object-oriented**, just as ruby was too
  - macros and ASTs like Haxe
  - concurrency like Go
  - uses ruby's (or jekyll's?) simple yaml config (build?) file to fetch dependencies, making it very simple get dependencies from git/github
  - makes writing C-bindings easy! and perhaps generatable? :)
  - compiles to C (like Haxe), allowing it to use C compilers, and therefore making it really fast
  - i think they are building some way to be able to interop with ruby, so as to re-use existing ruby libraries...
  - this language is the one that **appeals to me the most**, as i've missed the whole ruby generation, but maybe can join it late with this :) ...but it seems to offer very little over Haxe, which already has most of these features, and many more years behind it
    - like Haxe, i *think* it uses the Boehm garbage collector (mentioned in a post from 2013), so, i don't think it'll offer any better performance than Haxe... thus, it would just be syntax, which imo isn't enough fo a reason
      - the garbage collector: https://github.com/ivmai/bdwgc
  
Nim
  - performance-oriented, allowing for many kinds of optimizations and implementations (compiled, static-typed), but still **garbage collected** (this is the biggest difference between this and Rust), though, you can do some manual memory management to change the way it is collected, in the end, it's still garbage collected
  - **_feels_ like scripting in a compiled language, making it much more joyful to use :)**
  - composition > inheritance  
  - python-like tab-delimited style
  - **basically supports all programming paradigms**
  - interface with C/C++/Objective-C and compiles to javascript
  - made for embedded systems?
  - pop contemporary features: generics, closure, functional features, type inference, macro, statement as expression, etc.
  - easy C binding
  - another major new-comer, closest contender to Crystal, but the python-like style still throws me off :( i personally prefer object-oriented, slightly faster, ruby-style Crystal, as i don't even know any of the other programming paradigms

**Rust**
  - **like C/C++ but safe--no run-time errors(!?!?)**, **no garbage collector**, instead, using a specific memory management system, wherein you still have fine control of memory but it's easier(?) and guaranteed to be safe. you *must* learn and use this system to handle the memory yourself (just as you must learn Obj-C's reference counting, or C++'s pointers and smart pointers), thus if ever there's a problem with a garbage collector you'll either write that portion of code in C/C++ or just end up re-writing the whole thing with Rust
    - all of that of course comes with the cost of a slower development time (or at least having to be way more careful)
    - mutability: https://doc.rust-lang.org/std/keyword.mut.html, https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/mutability.html
    - https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html
  - performance-oriented, allowing for many kinds of optimizations and implementations
  - **incredible documentation design**: a web book, docs, crates (it's package manager), all look *stunning*. Languages with smaller communities will have a tough time matching that!
    - see: https://doc.rust-lang.org/std/index.html, 
    - the book: https://doc.rust-lang.org/book/
  - a great and excited community
  - composition > inheritance
  - Go's concurrency/threading features
  - brace-delimited style
  - pop contemporary features: generics, closure, functional features, type inference, macro, statement as expression…  
  - **people seem to really quite like this one**, many new game-frameworks are made with this, and it makes sense, as it has the right features for it
  - people have went crazy making Rust bindings for nearly every C/C++ library out there.., maybe writing C bindings have become easier? ...Or area they completely re-writing all these libraries!?
  - Bevy game engine, also see "awesome gamdev rust" on github
  - https://discord.com/blog/why-discord-is-switching-from-go-to-rust
    - this article tells of a single example of many where Discord replaced Rust because they were hitting the limit of Go's garbage collector, and to their surprise, beyond that problem, it outperformed go in every way anyway
  - Mozilla, and as always, open-source
  


  
Dart
  - considered pretty dull, but it works; open-source, **designed to be cross-platform**
  - Flutter, and this is really all it's got behind it
  - Google

Swift
  - Apple's native language, replacing Objective-C, and i believe a lot of code was rewritten using it
  - looks really good actually, simple yet powerful, like Haxe, and most importantly
  - probably has extremely good interopability with C/C++/Obj-C
  - open-source (surprisingly!)
  - **meant to be cross-platforn... but, what's the point when all of Apple's frameworks are closed products?..**
    - "core libraries" seem to be the same as .NET core libraries
    - https://www.swift.org/core-libraries/
    - https://www.swift.org/about/
      - "One of the most exciting aspects of developing Swift in the open is knowing that it is now free to be ported across a wide range of platforms, devices, and use cases.
         Our goal is to provide source compatibility for Swift across all platforms, even though the actual implementation mechanisms may differ from one platform to the next."
  - also, **like Google, Apple sucks with community / documentation / etc. A lot of power really comes from open-source popularity...**
  - Apple
  
  






## others: not for useful for games, or just history

### functional languages
  - "Elixir is a functional language; its data structures are immutable. This is great for reasoning about code and supporting the massive concurrency you enjoy when you write Elixir. The double-edged sword of immutable data structures is that mutations are modeled by taking an existing data structure and an operation and creating a brand new data structure that is the result of applying that operation to the existing data structure."
    - this basically applies to most functional languages

Elixer
  - "Elixir is a dynamic, **functional** language for building scalable and maintainable applications." says it's home-page
    - proably not the most performance-oriented, but it being new, surely it's faster than python/ruby!
  - again, very Ruby-eque, but really a replacement of Erlang, of which it shares it's specific VM, thus allowing one to re-use Erlang's libraries
  - but as opposed to Ruby's focus on object-oriented paradigm, it focuses on Ruby's concise functional style: of creating very short easy-to-read simple often single-line functions
  - not really suitable for games, i think..


### server-side specialization (concurrency, functional)
Go
  - seems to be like a contemporary C, but with a garbage collector, yet you can still use pointers 'n references, it's just "safer"
  - **at the speed of C too! :o**
  - **not object-oriented**, or not meant to be
    - this kills it for games
  - used by a ton of huge web companies, thanks to it's built-in concurrency (goroutines), making it very good for web APIs
  - simple, straight-forward, procedural style (like C), but pretty spartan and feature-less (also like C), making it far less appealing for hobbyists (that like *natural* languages) and game-makers (that like lots of features and object-oriented paradigm)
  - this seems to have influenced a lot of languages, especially it's concurrency features
  - Google, but open-source
    - basically replaced a bunch of slow python code




### old / history
ActionScript (3)
  - thanks to Flash and it's game engines FlashPunk and Flixel, i was able to make my first *little* games with them! :)
  - to this day, that was the best game dev experience i've ever had: pure code-only **light-weight scripting**
  - Haxe feels very close to ActionScript in both syntax and features, and really just made the perfect replacement for it, so, there's no need for this now, but good to note for history's sake
    - *update:* as it turns out, Nicholas (the maker of Haxe) wrote the compiler for ActionScript 2 :o ...now it all makes sense..!
  - my second love, leading me to Haxe


https://www.atatus.com/blog/rust-vs-golang/



# "server-side", "scripting" languages:
usually have an interpreter so that you can run it ("in run-time") via CLI with single commands or scripts, as opposed to having to be compiled *and then* ran ...although, nowadays, this dividing line is quite blurry

see https://stackoverflow.com/questions/17253545/scripting-language-vs-programming-language

https://softwareengineering.stackexchange.com/questions/53624/can-c-be-used-as-a-server-side-web-development-language
  - ANYTHING can be used to write a webpage provide it can read the input, write interpretable output, and is executable by the webserver.
    Technically, any language can be used as a CGI script... :thinking:


## the standards
**haxe**
  - **my favorite** language
  - compiled, static-typed
  - runs on front-end and back-end
  - can interop with C/C++
    - can even automatically generate the bindings!
  - **can compile to any language, including C**
    - but beware, this route would probably make it hard to debug
  - **compiles to bytecode then is run through a very fast VM (Neko, HashLink), like Lua**
  - made by one French guy

ruby
  - like Haxe, seems to have a nice cult community of hackers :)
    - this alone makes it much more appealing to me than the other pop general languages
  - also like Haxe, whereas Haxe devs tend to write object-oriented programs, Ruby in itself *is* object-oriented
  - quite slow :(
    - also can be compiled via C-ruby?
  - made by one Japanese guy
    
python
  - most popular and most loved
  - can interop with C/C++
  - dynamic
  - very slow
    - also can be compiled via C-Python?, down to bytecode, run in a VM like Java, and it'll still be 2x slower than ruby!
  - **pypy**, is an especially fast implmentation putting it at Lua speeds
  
java
  - similar to C++ but without memory management (pointers)
  - similar to Haxe in that it is converted down to bytecode and then run through a VM (JVM)
  
 
## not really server-side, but it's possible to build web apps!
C#
  - **through ASP.NET Core, can build cross-platform apps (including web** via WebAssembly)
    - this makes it a great choice, competing with not just web apps, but Google's Flutter, and even simple game-like apps.
  - Avalonia framework
    - like Flutter, but with C#/.NET/VS :o
  - Uno framework
    - like Flutter, a little different in implementation, more mobile-oriented, including hot-reloading :o
  - for a long time this only worked with Windows servers (IIS), thus making it less popular, but since ASP.NET *Core* in around 2015, it has since then become open-source, cross-platform (along with VS Code!), making MicroSoft look much better to the dev communities than both Google and Apple!
  - the con of this is that you need a solid development environment: the current version of Visual Studio (not VS Code), probably a Windows IIS server(??), and still need to compile the code, build it, then deploy it, making the entire build process far more cumbersome compared to the common server-side langugaes, where you can just go in with a terminal, edit some code, 'n run it all via CLI
  - however, **for big, serious projects, it's worth the powerful language (C#), framework (.NET), and environment (VS), all of which are perhaps considered some of the best**
  - C# also has one of the biggest dev communities
  
dart
  - Google's Haxe
  - used for the cross-platform (including web) Flutter framework
  - i personally don't trust Google in general, as they never work with the dev communities, never update their software, and often abandon their own software, making very strange one-off products
  - is it even open-source!?!?
    
  
# others
kotlin
  - Google replaced java with this for their Android devices
  - i'm guessing it interops/embeds with java
  - i don't know anymore about it..

perl
  - i've always viewed this as a terse, perplexing langauge, like regex
  - seems to have the reputation that only old veteran hackers have ever mastered it
  - embeds/interops with C/C++?
  
scala
  - allows for both object-oriented paradign and functional paradigm, thus making it less popular compared to solely object-oriented languages
  - uses java's VM: JVM, thus making it work seamlessly alongisde java?

javascript
  - an old dynamic front-end rather mundane language that has over time become used for everything because of the abundance of web devs, including server-side
  - through Node.js, Express.js, etc. 'middle-ware" frameworks, it can then be used server-side
  - dynamic typing, retarded manual type checking (===, NaN, etc.)
  - Google's v8 engine compiles javascript into machine code, instead of using the normal interpreter method, thus single-handedly causing this entire mess

PHP
  - perhaps the only thing worse than javascript, and perhaps closest to the horror that is objective-c
  - have you ever seen WordPress?.. :sob:
  
  
  
# popularity / use

10%-15%
Python
C
Java

5%+
C++
C#

1%+
Go
Swift
Ruby

...the rest

https://www.tiobe.com/tiobe-index/


# language compilation speed
just a very very very broad gut feeling, lol

tier 1 (manual memory management) *for crazy game engine people only*:
**Rust** (borrow-checker)
C++
C
Go (manual?)
Chapel (manual?)

tier 1 (garbage collected) for me! :)
  - these are somehow comparable to the speeds of the non-gc languages... :o
**Crystal**
  - Ruby syntax but as fast as C++?? wtf
Java
  - why on earth have people suffered all these years using C++ instead of Java??
**Dart**
Kotlin
Swift (manual? reference counting)
**Haxe**
  - not in the benchmark, and not sure where this goes..

tier 2:
  - these add features but come at the cost of being a few times slower, of course, depending on how you use them
Scala
**C#**
**Nim**
Lua (LuaJIT -j)


Python (pypy)
Elixer


tier 3 (interpreted) *not for games!!*
Ruby - ~5x slower
Lua - ~5-15x slower
Python - ~10-15x slower

Perl - ~20+ slower

https://benchmarksgame-team.pages.debian.net/benchmarksgame/
  - a joke, and hard to read, because it's more of a competition in which people upload crazy optimized programs that use multiple-cores/threads, but you can kinda see the limits and means using the simple implementations



# resources
https://blog.back4app.com/server-side-programming-languages/
  - a pretty simple and good summary of the popular languages (although, no haxe :( )
  
https://community.haxe.org/t/how-does-haxe-hxcpp-performance-compare-to-writing-c-c/460

https://www.reddit.com/r/gamedev/comments/1edn03/lua_angelscript_haxe_c_java_and_others_which_do/
  - shares my conundrum: an indie dev trying to choose a language environment, and it seems, even 8 years ago C#/MonoGame was still the way to go
  
https://www.reddit.com/r/ruby/comments/5c1prl/ruby_vs_python/
  - always good to gather some real thought from real people
  
  
 
 
https://blog.discord.com/using-rust-to-scale-elixir-for-11-million-concurrent-users-c6f19fc029d3


  
  
  
