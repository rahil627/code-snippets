# compare languages by reading them

https://learnxinyminutes.com/

good examples:

ruby:
https://github.com/benbalter/jekyll-optional-front-matter/blob/main/lib/jekyll-optional-front-matter/generator.rb



# what langauge is best for my needs?

## my needs (or wants?)

it should be "high-level" (specifically, not forced to handle pointers, references, and const), preferrably wiith many cool contemporary features
it should be relatively fast (at least faster than ruby and python interpreters)

for simple fun OS shell and web server hackery: :D
  - it should have an interpreter, so that you can just run it via cli
  - it should be able to run on both server-side and client-side (both: interpreter or compiled, for simple scripts and complex games/apps)
  
for games (and other "creative" applications that use various input/output hardwares): :D
  - it should have the option of memory management, for fine-tuning intense computations on both the CPU and the GPU, yet i should'nt be forced to handle memory, thus
    - it should have automatic garbage collection (pass by reference), yet 
    - it should allow the option to write "unmanaged code" *and/or* make it very easy to interop with C/C++ so that you can just write C/C++ when needed *(note: nearly all langauges allow this..)*
  - it should be designed to be cross-platform, or at least have that in mind
    - compile to C (for most platforms: desktop OSs, iOS (+ iPadOS), consoles, embedded devices, etc.)
    - maintain a set of libraries for target platforms: iOS > desktop OSs > consoles > the rest, in that order
    x/- compile to Java for Andriod (i personally don't care about this platform... non-iOS mobile devices are a mess)
  
  
as far as i know, only C# (Microsoft), Haxe (indie), and maybe Dart (Google) fit all of the above requirements above. The need for cross-platform targets really narrow down the choices, as most newer languages just won't have the libraries, *yet* (they hae the potential, as long as they can compile down to C). It's really up to the people, including big corporations, to build them up, along with building various frameworks using them, and then to maintain them... Only time will tell. Beyond C#, Haxe, and Dart though, i haven't really seen many good cross-platform libraries... *todo: I'd have to look into the C# and Haxe cross-platform libs to understand this bit a bit more... like, is it easy to just call a C# function that calls the native iOS function for "share"? If so, then *that's major*, for me, a game-breaker, really. Otherwise, you'd have to maintain an entire set of iOS bindings, and bindings for every other platform.*

as far as using C# as a scripting language, well, there's the Rosyln compiler (part of open-source .NET foundation) and "cs script", but i'd have to look into it some more.. but **if you can script in C#, then, well, it might just be game over for any other language!**

**nearly all high-level languages interop with C, so, i see no reason to write an *entire* program in C or C++**, leave that to the game-engine makers, and **anyway, you can always write C/C++ for the intensive sections when needed** (i doubt i'll ever need to). *I don't want to even think about pointers or references, and definitely not smart pointers! :barf:* Java is the lowest i'd stoop.

in the case of iOS, as long as there is a compiler for the language that can compile it to C, then there's a possibility.





# important changes in dev tech

## WebGL is dead. Long live native dev.
with WebAssembly now, can just skip the whole HTML5/WebGL crap and basically run native apps (machine code?) in the web-browser :o :O luckily, i've never cared about web-targets, but now it's finally really dead! :) No Flash. No HTML5/WebGl. *Long live native dev.*

## Microsoft <3 games *and* now open-source too?
.NET *Core* is like a whole new revamped open-source cross-platform beast. In the past, Microsoft/.NET was tied to Windows, and so *the people* created Mono as an open-source cross-platform version of .NET, but now, the new .NET Core can truly be used to make *everything*! (I guess Mono is dead..? Or maybe it was used as a base for .NET Core??) *The C#/.NET stock is rising...* Thus, app frameworks like **Avalonia** and **Uno** can compete with Google's Flutter, and the game frameworks like **Unity** and **MonoGame** (based on Microsoft's own XNA framework used in the original Xbox) are still respectively the *the kings of indie game engines*. Microsoft is doing well. All of that, alongside open-source-made VS Code, and the fact that Windows always had a monopolty on games. Microsoft has always been closer to games than both Google and Apple have ever have been, and now it's really showing.



# a few contemporary languages, old and new

## old classics
**C#**
  - mighty mighty C#... along with it's .NET framework and Visual Studio, is really tough to beat
  - *incredible feature-set* for the language, the standard library, and the .NET library
  - has great frameworks for both cross-platform apps (Avalonia, Uno, ASP.NET?) and games (Unity, MonoGame)
    - and as long as these frameworks exist, it's cross-platform libraries will be in top-notch condition
    - probably also used by Microsoft themselves for making Xbox games
  - always had a compiled approach instead of scripting, making it less popular in the web-dev world, which made it even better, as it keeps the serious native big game/app devs away from the horrendous temporal javascript/electron/html5 web-dev world
  - Microsoft, and very much *feels* like Microsoft: *heavy*, heavy dev environment, heavy libraries, clunky standard coding convention, etc.
  - after using this, it feels like there's really no reason to use anything else! (todo: :thinking:)
  - has a contemporary **scripting** solutions!!?? :o :O
    - Rosylyn compiler
    - csscript
    - https://github.com/filipw/dotnet-script
    - **todo: with this, there's not much reason for even Haxe, then is there?...** :thinking:
  - https://www.nuget.org/packages/MonoGame.Framework.WpfInterop/ - LOL, amazing! WPF UI with MonoGame behind it
  - nuget package library
  - my first love
  
*Haxe**
  - simple, *light-feeling*--feels like a scripting language!, **powerful like C#**, but without all the *heaviness* of it, **feeling more like Ruby**, just *siiiick*
    - also like Ruby, it feels very *Linux-y*, where **everything is a simple text file**, including the build file (this is a major difference in feeling to C#, as it can feel like you must edit stuff in VS's gui, or even Unity's gui. In Haxe, **everything can be done by simple text editing**, no gui software necessary)
  - maybe the first major language with **cross-platform** in mind?
  - has all of the features of ruby (container filters, anonymous functions, etc.) plus more, but comes with a *much much* faster compiler, making Ruby feel rather obsolete, and just surviving off of it's libraries and community
  - adds macros, ASTs, static extensions, etc.
  - **_incredible_ compilation options: compile to nearly any other language (including C, which can then be compiled again by optmized-compiler LLVM to reach near-C speeds, or to use C libraries, or to build in C for iOS/consoles/embedded devices, and javascript, to be run in a browser or to use pop javascript libraries or to compile to Node.js, and Java, to build for Android, and to bytecode which is then run by a VM (Neko [old VM?], HashLink [current VM]), itself with two options: HL/JIT and HL/C**, one for faster compilation speed and one for optimized run-time speed *whoa...*
  - don't feel overwhelmed by decades of C/C++ libraries to piece together, nor have to think about pointers/references/smart-pointers and header files
  - don't feel like one has to conform to the ways of Microsoft and the .NET framework: you can write your code in any way you want to, and use any tools you want to too! :)
  - small community feeling, will run into the makers on the forums, discord, or github (including the maker of Haxe/Heaps himself!!), can make a big difference :)
  - frameworks like OpenFL, NME, Heaps ensures it's shared cross-platform code is in good condition, though not .NET level
  - haxelib package manager
  - **my fav :)**

Ruby
  - scripting people seem to really *love* this one
  - aims to be natural, like English;
    - also_uses_snake_case_convention :o *finally*, someone gets it! although, maybe-i-like-this-better
    - uses function-name? for functions that return true/false *neat!*
  - *very clean* syntax
    - uses the last statement's expression in a function as the return value, thus saving a line; and oh you can easily write one-liner functions with Ruby! :o
    - can omit the '()' in function()
    - no need for 'var'
  - seems to have an interesting, diverse, rad community vibe, similar to Haxe :) ...but *way* more web-dev-oriented, thanks to Rails, the language's premier web framework.., and Jekyll (used by GitHub Pages) too
  - *very* object-oriented, even in the language itself! (maybe C# got that idea from here..), allowing you to even hack away at the language itself! you can even add methods to the main parent Object that everything inherits!! :o *everything is an object*
  - **too slow for games, unless it has a compiler? :(**
    - maybe even too slow for big apps :/ (compare: Jekyll vs Go)
  - adds a ton of features: object.map => { anonymous function / lambda / closure / "block" (i dunno difference) }, container.select/find/filter {|item| item == item_i_want}, getter/setters, modules (this is interesting and have not seen before: basically can include group of methods to an object! :o), etc.
  - has incredible syntax: no var necessary?
  - see this for major differences: https://www.ruby-lang.org/en/documentation/ruby-from-other-languages/
  - game engines, such as Gosu, are written in C/C++ and then wrapped/binded by Ruby, because it would be too slow otherwise
  - Ruby Gems package manager
  - although i missed this generation, i think i would have enjoyed this little world :)  

Java/Scala
  - **compiles to bytecode that is then processed by VM that must be installed on the target device, whereas C/C++ directly accesses memory**
  - **adds a garbage collector, making it feel "high-level"**
    - but no pointers *at all*, **all objects are references and all objects are passed by references** (basically every high-level language after this does this)
      - thus perhaps making fine-tuning of memory impossible?
    - a good comparison between C++'s pointers and Java's magic
      - https://stackoverflow.com/questions/1750106/how-can-i-use-pointers-in-java#1750197
  - feels neat, like an early C#! :)
  - no header files? :o
  - object-oriented, direct contender to C++
  - adds lambdas (maybe this was added later on..)
  - can interop with C through JNI (java native interface)
  - LibGDX
  - this is a world i've seem to have avoided, just out of taste... i think this is because when i started, it just didn't have a good IDE compared to C++'s Visual Studio; i had to use Eclipse, which was garbage that unfortunately couldn't be collected :/  
    - however, now looking at it again, it's strange that this isn't used more! It looks like a much neater version of C++, like a pre-cursor to C#

  
C++
  - manual memory management via pointers 'n references 'n "smart" pointers 'n the const key-word
    - and therefore pass function arguments by value or pointer or reference or smart pointer too
  - adds **object-oriented design features (classes)** to C
    - also adds the idea of allocating stuff during constructor and de-allocating during deconstructor
  - adds references to C (i guess in C you just had to use pointers for everything..?)
  - smart pointers (3 kinds) that generally delete themselves once the last reference falls out of scope
    - this just makes it even more complex!! :( why worry about references and 3 kinds of smart pointers and raw pointers, when you can worry about raw pointers?
  - header files are also annoying
  - adds "standard library" including strings to C (before they were an array of "char"s)
  - adds generics ("templates"), enums, and other now basic features..
  - loved/hated, mostly hated, i think
  - strange development cycle, wherein cults choose which version they prefer the most (C++14, C++20, etc.)
  - also a choice of compilers (gcc, vs, dev-cpp, etc.)
  
C
 - **used as the "low-level" language by most electronic devices**
 - *very* simple
 - manual memory management via "raw" pointers (no references?) and the const key-word
 - *not* **object-oriented**
   - and interestingly, it forces you to write in a simple, top-to-bottom way, making programs, even if it's just a giant single file, rather easy to read, as opposed to being forced to create a ton of "objects", most of which don't make sense. With less freedom and more constraint, you are able to do what is needed without thinking about how to do it. There's a whole philosophy about this vocalized by Casey Muratori and his hand-made network. And indeed, it makes C libraries much easier to follow along than C++ libraries:
 - has header files, which is annoying, but it seems nowadays people just write everything in the header file!
 - Raylib is quite beautiful: simple, straight-forward, because there's really no other way to do it
 - OpenFrameworks also has Raylib's beauty (not sure if it's C or C++ tho..)
 - now, i'm not sure if i'd want to write a game in that style, *i loved FlashPunk!, i love my objects! ;(*, but i sorta see why straight up simple C results in very good code, dividing data from functions, ending up to be more modular, more re-usable, and most importantly, easy to follow


## newer stuff
**Crystal**
  - like a compiled and static-typed ruby, along with *much* faster, in fact, **at C++ speeds!?!?** :o :O
  - sytax and style *very very* similar to ruby, like 75% similar!
  - deeply **object-oriented**, just as ruby was too
  - macros and ASTs like Haxe
  - concurrency like Go
  - uses ruby's (or jekyll's?) simple yaml config (build?) file to fetch dependencies, making it very simple get dependencies from git/github
  - makes writing C-bindings easy! and perhaps generatable? :)
  - compiles to C (like Haxe), allowing it to use C compilers, and therefore making it really fast
  - i think they are building some way to be able to interop with ruby, so as to re-use existing ruby libraries...
  - this language is the one that **appeals to me the most**, as i've missed the whole ruby generation, but maybe can join it late with this :) ...but it seems to offer very little over Haxe, which already has most of these features, and many more years behind it
  
Nim
  - performance-oriented, allowing for many kinds of optimizations and implementations (compiled, static-typed), but still **garbage collected** (this is the biggest difference between this and Rust), though, you can do some manual memory management to change the way it is collected, in the end, it's still garbage collected
  - **_feels_ like scripting in a compiled language, making it much more joyful to use :)**
  - composition > inheritance  
  - python-like tab-delimited style
  - **basically supports all programming paradigms**
  - interface with C/C++/Objective-C and compiles to javascript
  - made for embedded systems?
  - pop contemporary features: generics, closure, functional features, type inference, macro, statement as expression, etc.
  - easy C binding
  - another major new-comer, closest contender to Crystal, but the python-like style still throws me off :( i personally prefer object-oriented, slightly faster, ruby-style Crystal, as i don't even know any of the other programming paradigms

Dart
  - todo
  - **designed to be cross-platform**
  - Flutter
  - ...i haven't really seen any game frameworks in this... yet? Flame Engine exists on top of Flutter, lol? (that does not sound like a good idea... probably limited to Skia graphics..)
  - Google
    - although Flutter seems really nifty... i'd personally choose Microsoft's C#/.NET world over this *any day*

Rust
  - **like C/C++ but safe**, using a specific memory management system, wherein you still have fine control of memory, but apparently it's not as bad as C/C++ (run-time safety, etc.). **no garbage collector**, you *must* learn and use this system to handle the memory yourself (probably like learning Obj-C's reference counting), *"a true systems programming language"* for *true game engine programmers*
    - all of that of course comes with the cost of a slower development time
  - performance-oriented, allowing for many kinds of optimizations and implementations (compiles, static-typed)
  - composition > inheritance
  - Go's concurrency/threading features
  - brace-delimited style
  - pop contemporary features: generics, closure, functional features, type inference, macro, statement as expression…  
  - **people seem to really quite like this one**, many new game-frameworks are made with this, and it makes sense, as it has the right features for it
  - people have went crazy making Rust bindings for nearly every C/C++ library out there.., maybe writing C bindings have become easier? ...Or area they completely re-writing all these libraries!?
  - Bevy game engine
  - Mozilla, and as always, open-source

Odin
  - from the hand-made network
  - like C, not object-oriented, with a belief that *data and procedures should be seperate, and that behaviors shouldn't even exist!* :o very rad
  - influenced by Go



## others
Go
  - seems to be like a contemporary C, but with a garbage collector, yet you can still use pointers 'n references, it's just "safer"
  - **at the speed of C too! :o**
  - **not object-oriented**, or not meant to be
    - this kills it for games
  - used by a ton of huge web companies, thanks to it's built-in concurrency (goroutines), making it very good for web APIs
  - simple, straight-forward, procedural style (like C), but pretty spartan and feature-less (also like C), making it far less appealing for hobbyists (that like *natural* languages) and game-makers (that like lots of features and object-oriented paradigm)
  - this seems to have influenced a lot of languages, especially it's concurrency features
  - Google, but open-source
  
ActionScript (3)
  - thanks to Flash and it's game engines FlashPunk and Flixel, i was able to make my first *little* games with them! :)
  - to this day, that was the best game dev experience i've ever had: pure code-only **light-weight scripting**
  - Haxe feels very close to ActionScript in both syntax and features, and really just made the perfect replacement for it, so, there's no need for this now, but good to note for history's sake
  - my second love, leading me to Haxe
    
Pony
  - lol, i like this idea, extremely statically typed, so that it's never a question, no concept of memory management



https://www.atatus.com/blog/rust-vs-golang/




# "server-side", "scripting" languages:
usually have an interpreter so that you can run it ("in run-time") via CLI with single commands or scripts, as opposed to having to be compiled *and then* ran ...although, nowadays, this dividing line is quite blurry

see https://stackoverflow.com/questions/17253545/scripting-language-vs-programming-language

https://softwareengineering.stackexchange.com/questions/53624/can-c-be-used-as-a-server-side-web-development-language
  - ANYTHING can be used to write a webpage provide it can read the input, write interpretable output, and is executable by the webserver.
    Technically, any language can be used as a CGI script... :thinking:


## the standards
**haxe**
  - **my favorite** language
  - compiled, static-typed
  - runs on front-end and back-end
  - can interop with C/C++
    - can even automatically generate the bindings!
  - **can compile to any language, including C**
    - but beware, this route would probably make it hard to debug
  - **compiles to bytecode then is run through a very fast VM (Neko, HashLink), like Lua**
  - made by one French guy

ruby
  - like Haxe, seems to have a nice cult community of hackers :)
    - this alone makes it much more appealing to me than the other pop general languages
  - also like Haxe, whereas Haxe devs tend to write object-oriented programs, Ruby in itself *is* object-oriented
  - quite slow :(
    - also can be compiled via C-ruby?
  - made by one Japanese guy
    
python
  - most popular and most loved
  - can interop with C/C++
  - dynamic
  - very slow
    - also can be compiled via C-Python?, down to bytecode, run in a VM like Java, and it'll still be 2x slower than ruby!
  - **pypy**, is an especially fast implmentation putting it at Lua speeds
  
java
  - similar to C++ but without memory management (pointers)
  - similar to Haxe in that it is converted down to bytecode and then run through a VM (JVM)
  
 
## not really server-side, but it's possible to build web apps!
C#
  - **through ASP.NET Core, can build cross-platform apps (including web** via WebAssembly)
    - this makes it a great choice, competing with not just web apps, but Google's Flutter, and even simple game-like apps.
  - Avalonia framework
    - like Flutter, but with C#/.NET/VS :o
  - Uno framework
    - like Flutter, a little different in implementation, more mobile-oriented, including hot-reloading :o
  - for a long time this only worked with Windows servers (IIS), thus making it less popular, but since ASP.NET *Core* in around 2015, it has since then become open-source, cross-platform (along with VS Code!), making MicroSoft look much better to the dev communities than both Google and Apple!
  - the con of this is that you need a solid development environment: the current version of Visual Studio (not VS Code), probably a Windows IIS server(??), and still need to compile the code, build it, then deploy it, making the entire build process far more cumbersome compared to the common server-side langugaes, where you can just go in with a terminal, edit some code, 'n run it all via CLI
  - however, **for big, serious projects, it's worth the powerful language (C#), framework (.NET), and environment (VS), all of which are perhaps considered some of the best**
  - C# also has one of the biggest dev communities
  
dart
  - Google's Haxe
  - used for the cross-platform (including web) Flutter framework
  - i personally don't trust Google in general, as they never work with the dev communities, never update their software, and often abandon their own software, making very strange one-off products
  - is it even open-source!?!?
    
  
# others
kotlin
  - Google replaced java with this for their Android devices
  - i'm guessing it interops/embeds with java
  - i don't know anymore about it..

perl
  - i've always viewed this as a terse, perplexing langauge, like regex
  - seems to have the reputation that only old veteran hackers have ever mastered it
  - embeds/interops with C/C++?
  
scala
  - allows for both object-oriented paradign and functional paradigm, thus making it less popular compared to solely object-oriented languages
  - uses java's VM: JVM, thus making it work seamlessly alongisde java?

javascript
  - an old dynamic front-end rather mundane language that has over time become used for everything because of the abundance of web devs, including server-side
  - through Node.js, Express.js, etc. 'middle-ware" frameworks, it can then be used server-side
  - dynamic typing, retarded manual type checking (===, NaN, etc.)
  - Google's v8 engine compiles javascript into machine code, instead of using the normal interpreter method, thus single-handedly causing this entire mess

PHP
  - perhaps the only thing worse than javascript, and perhaps closest to the horror that is objective-c
  - have you ever seen WordPress?.. :sob:
  
  
  
# popularity / use

10%-15%
Python
C
Java

5%+
C++
C#

1%+
Go
Swift
Ruby

...the rest

https://www.tiobe.com/tiobe-index/


# language compilation speed
just a very very very broad gut feeling, lol

tier 1 (manual memory management) *for crazy game engine people only*:
**Rust** (borrow-checker)
C++
C
Go (manual?)
Chapel (manual?)

tier 1 (garbage collected) for me! :)
  - these are somehow comparable to the speeds of the non-gc languages... :o
**Crystal**
  - Ruby syntax but as fast as C++?? wtf
Java
  - why on earth have people suffered all these years using C++ instead of Java??
**Dart**
Kotlin
Swift (manual? reference counting)
**Haxe**
  - not in the benchmark, and not sure where this goes..

tier 2:
  - these add features but come at the cost of being a few times slower
Scala
**C#**
**Nim**
Lua (LuaJIT -j)


Python (pypy)
Elixer


tier 3 (interpreted) *not for games!!*
Ruby - ~5x slower
Lua - ~5-15x slower
Python - ~10-15x slower

Perl - ~20+ slower

https://benchmarksgame-team.pages.debian.net/benchmarksgame/
  - a joke, and hard to read, because it's more of a competition in which people upload crazy optimized programs that use multiple-cores/threads, but you can kinda see the limits and means using the simple implementations



# resources
https://blog.back4app.com/server-side-programming-languages/
  - a pretty simple and good summary of the popular languages (although, no haxe :( )
  
https://community.haxe.org/t/how-does-haxe-hxcpp-performance-compare-to-writing-c-c/460

https://www.reddit.com/r/gamedev/comments/1edn03/lua_angelscript_haxe_c_java_and_others_which_do/
  - shares my conundrum: an indie dev trying to choose a language environment, and it seems, even 8 years ago C#/MonoGame was still the way to go
