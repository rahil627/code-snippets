# what langauge is best for my needs?

## my needs (or wants?)

it should be high-level with lots of cool contemporary features
it should be relatively fast (faster than ruby and python interpreters)

for simple fun web server hackery :D
  - it should have an interpreter, so that you can run it via cli
  - it should be able to run server-side (interpreter) and client-side
  
for games (and other "creative" applications that use various input/output hardwares) :D
  - it should have the option of memory management, for fine-tuning intense computations on both the CPU and the GPU, yet i should'nt be forced to handle memory, thus
    - it should have automatic garbage collection, yet 
    - it should allow the option to write "unmanaged code", or better yet, make it very easy to interop with C/C++ so that you can just write C/C++ when needed
  - it should be designed to be cross-platform (not sure how.., have stable, maintained cross-platform libraries?)
  
  
as far as i know, only C#, Haxe, and maybe Dart fit all of the above requirements above. The cross-platform libraries really narrow down the choices, as most newer languages just won't have that, *yet*. It's really up to the people, including big corporations, to build them up, along with building various frameworks using them, and to maintain them... Only time will tell. Beyond C# and Haxe though, i haven't really seen many good cross-platform libraries... todo: I'd have to look into the C# and Haxe cross-platform libs to understand this bit a bit more... like, is it easy to just call a C# function that calls the native iOS function for "share"? If so, then *that's major*, imo. A game-breaker, really. Otherwise, you'd have to maintain an entire set of iOS bindings, and bindings for every other platform.





# important changes in dev tech
with WebAssembly now, can just skip the whole HTML5/WebGL crap and basically run native apps (machine code?) in the web-browser :o :O luckily, i've never cared about web-targets, but now it's finally really dead! :) No Flash. No HTML5/WebGl. *Long live native dev.*

.NET *Core* is like a whole new revamped open-source cross-platform beast. In the past, Microsoft/.NET was tied to Windows, but now, C#/.NET can truly be used to make *everything*! *The C#/.NET stock is rising...* Thus, app frameworks like **Avalonia** and **Uno** can compete with Google's Flutter, and the game framework **MonoGame** is still *the king of indie game engines*. Microsoft is doing well. All that, alongside VS Code. Microsoft has always been closer to games than both Google and Apple have ever have been.



# a few contemporary languages

## old classics
**C#**
  - mighty mighty C#... along with it's .NET framework and Visual Studio, is really tough to beat
  - *incredible feature-set* for the language, the standard library, and the .NET library
  - has great frameworks for both cross-platform apps (Avalonia, Uno, ASP.NET?) and games (Unity, MonoGame)
    - and as long as these frameworks exist, it's cross-platform libraries will be in top-notch condition
  - always had a compiled approach instead of scripting, making it less popular in the web-dev world, which made it even better, as it keeps the serious native big app devs away from the horrendous javascript/electron/html5 web-dev world
  - Microsoft, and very much *feels* like Microsoft: *heavy*, heavy dev environment, heavy libraries, standard coding convention, etc.
  - after using this, it feels like there's really no reason to use anything else! (todo: hmmmmm)
  - has a contemporary **scripting** solution!!?? :o :O
    - https://github.com/filipw/dotnet-script - 
    - **todo: with this, there's not much reason for even Haxe, then is there?...** :thinking:
  - https://www.nuget.org/packages/MonoGame.Framework.WpfInterop/ - LOL, amazing! WPF UI with MonoGame behind it
  - nuget package library
  
*Haxe**
  - my fave :)
  - simple, *light-feeling*--feels like a scripting language!, powerful like C#, but without all the *heaviness* of it, cross-platform-oriented, just *siiiick*
  - don't feel overwhelmed by the decades of C/C++ libraries to piece together
  - don't feel like one has to conform to the ways of Microsoft and the .NET framework: you can write your code your own way! :)
  - small community feeling, can make a difference :)
  - frameworks like OpenFL, NME, Heaps ensures it's shared cross-platform code is in good condition, though not .NET level

Java/Scala
  - adds a garbage collector, making it feel "high-level"
  - this is a world i've seem to have avoided, just out of taste... i think this is because when i started, it just didn't have a good IDE compared to C++'s Visual Studio; i had to use Eclipse, which was garbage that couldn't be collected
  
C++
  - adds **object-oriented** to C
  - loved/hated, mostly hated, i think
  - strange development cycle, wherein cults choose which version they prefer the most (C++14, C++20, etc.)
  - manual memory management via pointers 'n references
  
C
 - manual memory management via pointers 'n references
 - *not* **object-oriented**
   - and interestingly, it forces you to write a simple, top-to-bottom way, making programs, even if it's just a giant single file, rather easy to read, as opposed to being forced to create a ton of "objects", most of which don't make sense. With less freedom and more constraint, then you are able to do what is needed without thinking about how to do it. There's a whole philosohpy about this with Casey Muratori's hand-made network. And indeed, it makes C libraries much easier to follow along than C++ libraries:
 - Raylib is quite beautiful: simple, straight-forward, because there's really no other way to do it
 - OpenFrameworks also has Raylib's beauty (not sure if it's C or C++ tho..)
 - now, i'm not sure if i'd want to write a game in that style, *i loved FlashPunk!, i love my objects! ;(*, but i sorta see why straight up simple C results in very good code, dividing data from functions, ending up to be more modular, more re-usable, etc. etc.


## newer stuff
**Crystal**
  - like a compiled and static-typed ruby, along with *much* faster, in fact, **at C++ speeds!?!?** :o :O
  - sytax and style *very very* similar to ruby, like 75% similar!
  - **object-oriented**, just as ruby was too
  - macros and ASTs like Haxe
  - concurrency like Go
  - uses ruby's (or jekyll's?) simple yaml config (build?) file to fetch dependencies, making it very simple get dependencies from git/github
  - makes writing C-bindings easy! and perhaps generatable? :)
  - compiles to C (like Haxe), allowing it to use C compilers, and therefore making it really fast
  - i think they are building some way to be able to interop with ruby, so as to re-use existing ruby libraries...
  - this language is the one that **appeals to me the most**, as i've missed the whole ruby generation, but maybe can join it late with this :) ...but it seems to offer very little over Haxe, which already has most of these features, and many more years behind it
  
Nim
  - performance-oriented, allowing for many kinds of optimizations and implementations (compiled, static-typed), but still **garbage collected** (this is the biggest difference between this and Rust), though, you can do some manual memory management to change the way it is collected, in the end, it's still garbage collected
  - **_feels_ like scripting in a compiled language, making it much more joyful to use :)**
  - composition > inheritance  
  - python-like tab-delimited style
  - **basically supports all programming paradigms**
  - interface with C/C++/Objective-C and compiles to javascript
  - made for embedded systems?
  - pop contemporary features: generics, closure, functional features, type inference, macro, statement as expression, etc.
  - easy C binding
  - another major new-comer, closest contender to Crystal, but the python-like style still throws me off :( i personally prefer object-oriented-only, *slightly faster*, ruby-style Crystal, as i don't even know any of the other programming paradigms
  
Rust
  - **like C/C++ but safe**, using a specific memory management system, wherein you still have fine control of memory, but apparently it's not as bad as C/C++ (run-time safety, etc.). **no garbage collector**, you *must* learn and use this system to handle the memory yourself (probably like learning Obj-C's reference counting), *"a true systems programming language"* for the *true game engine programmers*
    - all of that of course comes with the cost of a slower development time
  - performance-oriented, allowing for many kinds of optimizations and implementations (compiles, static-typed)
  - composition > inheritance
  - Go's concurrency/threading features
  - brace-delimited style
  - pop contemporary features: generics, closure, functional features, type inference, macro, statement as expressionâ€¦  
  - **people seem to really quite like this one**, many new game-frameworks are made with this, and it makes sense, as it has the right features for it
  - people have went crazy making Rust bindings for nearly every C/C++ library out there.., maybe writing C bindings have become easier?
  - Mozilla, and as always, open-source

Odin
  - from the hand-made network
  - like C, not object-oriented, with a belief that *data and procedures should be seperate, and that behaviors shouldn't even exist!* :o very rad
  - influenced by Go



## others
Go
  - seems to be like a contemporary C, and a good alternative to C++'s much hated development path
  - **at the speed of C :o**
  - used by a ton of huge web companies, thanks to it's built-in concurrency (goroutines), making it very good for web APIs
  - simple, straight-forward, procedural style, but pretty spartan and feature-less, making it far less appealing for hobbyists
  - todo: no memory management?? what? surely i read wrong..
  - this seems to have influenced a lot of languages, especially it's concurrency features
  - Google, but open-source
    
Pony
  - lol, i like this idea, extremely statically typed, so that it's never a question, no concept of memory management



https://www.atatus.com/blog/rust-vs-golang/


# language compilation speed
just a very very very broad gut feeling, lol

tier 1 (manual memory management) *for crazy game engine people only*:
**Rust** (borrow-checker)
C++
C
Go (manual?)
Chapel (manual?)

tier 1 (garbage collected) for me! :)
  - these are somehow comparable to Rust/C++ speeds... :o
**Crystal**
  - Ruby syntax but as fast as C++?? wtf
Java
  - why on earth have people suffered all these years using C++ instead of Java??
**Dart**
Kotlin
Swift (manual? reference counting)

tier 3:
  - these add features but come at the cost of being a few times slower
Scala
**C#**
**Haxe**
**Nim**
Lua (LuaJIT -j)


Python (pypy)
Elixer


tier 4 (interpreted) *not for games!!*
Ruby - ~5x slower
Lua - ~5-15x slower (not LuaJIT?)
Python - ~10-15x slower

Perl - ~20+ slower


# "server-side", "scripting" languages:
usually have an interpreter so that you can run it ("in run-time") via CLI with single commands or scripts, as opposed to having to be compiled *and then* ran ...although, nowadays, this dividing line is quite blurry

see https://stackoverflow.com/questions/17253545/scripting-language-vs-programming-language

https://softwareengineering.stackexchange.com/questions/53624/can-c-be-used-as-a-server-side-web-development-language
  - ANYTHING can be used to write a webpage provide it can read the input, write interpretable output, and is executable by the webserver.
    Technically, any language can be used as a CGI script... :thinking:


## the standards
**haxe**
  - **my favorite** language
  - compiled, static-typed
  - runs on front-end and back-end
  - can interop with C/C++
    - can even automatically generate the bindings!
  - **can compile to any language, including C**
    - but beware, this route would probably make it hard to debug
  - **compiles to bytecode then is run through a very fast VM (Neko, HashLink), like Lua**
  - made by one French guy

ruby
  - like Haxe, seems to have a nice cult community of hackers :)
    - this alone makes it much more appealing to me than the other pop general languages
  - also like Haxe, whereas Haxe devs tend to write object-oriented programs, Ruby in itself *is* object-oriented
  - quite slow :(
    - also can be compiled via C-ruby?
  - made by one Japanese guy
    
python
  - most popular and most loved
  - can interop with C/C++
  - dynamic
  - very slow
    - also can be compiled via C-Python?, down to bytecode, run in a VM like Java, and it'll still be 2x slower than ruby!
  - **pypy**, is an especially fast implmentation putting it at Lua speeds
  
java
  - similar to C++ but without memory management (pointers)
  - similar to Haxe in that it is converted down to bytecode and then run through a VM (JVM)
  
 
## not really server-side, but it's possible to build web apps!
C#
  - **through ASP.NET Core, can build cross-platform apps (including web** via WebAssembly)
    - this makes it a great choice, competing with not just web apps, but Google's Flutter, and even simple game-like apps.
  - Avalonia framework
    - like Flutter, but with C#/.NET/VS :o
  - Uno framework
    - like Flutter, a little different in implementation, more mobile-oriented, including hot-reloading :o
  - for a long time this only worked with Windows servers (IIS), thus making it less popular, but since ASP.NET *Core* in around 2015, it has since then become open-source, cross-platform (along with VS Code!), making MicroSoft look much better to the dev communities than both Google and Apple!
  - the con of this is that you need a solid development environment: the current version of Visual Studio (not VS Code), probably a Windows IIS server(??), and still need to compile the code, build it, then deploy it, making the entire build process far more cumbersome compared to the common server-side langugaes, where you can just go in with a terminal, edit some code, 'n run it all via CLI
  - however, **for big, serious projects, it's worth the powerful language (C#), framework (.NET), and environment (VS), all of which are perhaps considered some of the best**
  - C# also has one of the biggest dev communities
  
dart
  - Google's Haxe
  - used for the cross-platform (including web) Flutter framework
  - i personally don't trust Google in general, as they never work with the dev communities, never update their software, and often abandon their own software, making very strange one-off products
  - is it even open-source!?!?
    
  
# others
kotlin
  - Google replaced java with this for their Android devices
  - i'm guessing it interops/embeds with java
  - i don't know anymore about it..

perl
  - i've always viewed this as a terse, perplexing langauge, like regex
  - seems to have the reputation that only old veteran hackers have ever mastered it
  - embeds/interops with C/C++?
  
scala
  - allows for both object-oriented paradign and functional paradigm, thus making it less popular compared to solely object-oriented languages
  - uses java's VM: JVM, thus making it work seamlessly alongisde java?

javascript
  - an old dynamic front-end rather mundane language that has over time become used for everything because of the abundance of web devs, including server-side
  - through Node.js, Express.js, etc. 'middle-ware" frameworks, it can then be used server-side
  - dynamic typing, retarded manual type checking (===, NaN, etc.)
  - Google's v8 engine compiles javascript into machine code, instead of using the normal interpreter method, thus single-handedly causing this entire mess

PHP
  - perhaps the only thing worse than javascript, and perhaps closest to the horror that is objective-c
  - have you ever seen WordPress?.. :sob:


# resources
https://blog.back4app.com/server-side-programming-languages/
  - a pretty simple and good summary of the popular languages (although, no haxe :( )
  
https://programmingzen.com/10-lesser-known-programming-languages-worth-exploring/

https://www.reddit.com/r/gamedev/comments/1edn03/lua_angelscript_haxe_c_java_and_others_which_do/
  - shares my conundrum: an indie dev trying to choose a language environment, and it seems, even 8 years ago C#/MonoGame was still the way to go
