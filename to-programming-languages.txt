# a language for every application

for simple fun web server hackery :D
  - it should have an interpreter, so that you can run it via cli
  - it should be able to run server-side (interpreter) and client-side (VM)
  
for games (and other "creative" applications that use various input/output hardwares) :D
  - it should have the option of memory management, for fine-tuning intense computations on both the CPU and the GPU
  - it should interop or embed to C/C++
  - it should be designed to be cross-platform (not sure how..)
  
  
as far as i know, only Haxe fits all of the above requirements... i'm not sure how C# really works, and i haven't touched dart.



# important changes in dev tech
with WebAssembly now, can just skip the whole HTML5/WebGL crap and basically run native apps (machine code?) in the web-browser :o :O luckily, i've never cared about web-targets, but now it's finally really dead! :) No Flash. No HTML5/WebGl. *Long live native dev.*

.NET *Core* is like a whole new revamped open-source cross-platform beast. In the past, Microsoft/.NET was tied to Windows, but now, C#/.NET can truly be used to make *everything*! *The C#/.NET stock is rising...* Thus, app frameworks like **Avalonia** and **Uno** can compete with Google's Flutter, and the game framework **MonoGame** is still *the king of indie game engines*. Microsoft is doing well. All that, alongside VS Code. Microsoft has always been closer to games than both Google and Apple have ever have been.



# a few contemporary languages

## old classics
C#
  - mighty mighty C#... along with it's .NET framework and Visual Studio, is really tough to beat
  - *incredible feature-set* for the language, the standard library, and the .NET library
  - has great frameworks for both cross-platform apps (Avalonia, Uno, ASP.NET?) and games (MonoGame)
  - always had a compiled approach instead of scripting, making it less popular in the web-dev world, which made it even better, as it keeps the serious native big app devs away from the horrendous javascript/electron/html5 web-dev world
  - Microsoft, and very much feels like Microsoft: heavy, big dev environment
  - after using this, it feels like there's really no reason to use anything else! (todo: hmmmmm)
  
Haxe
  - my fave :)


## newer stuff
Crystal
  - like a compiled and static-typed ruby, along with *much* faster, in fact, **at C++ speeds!** :o
  - object-oriented, just as ruby was
  - macros and ASTs like Haxe
  - concurrency like Go
  - uses ruby's (or jekyll's?) simple yaml config (build?) file to fetch dependencies, making it very simple get dependencies from git/github
  - makes writing C-bindings easy! and perhaps generatable? :)
  - this language is the one that **appeals to me the most**, as i've missed the whole ruby generation, but maybe can join it late with this :) ...but it seems to offer very little over Haxe, which already has most of these features
  
Nim
  - performance-oriented, allowing for many kinds of optimizations and implementations (compiled, static-typed), but still **garbage collected** (this is the biggest difference between this and Rust), though, you can do some manual memory management to change the way it is collected, in the end, it's still garbage collected
  - **_feels_ like scripting in a compiled language, making it much more joyful to use :)**
  - composition > inheritance  
  - python-like tab-delimited style
  - basically supports all programming paradigms
  - interface with C/C++/Objective-C and compiles to javascript
  - made for embedded systems?
  - pop contemporary features: generics, closure, functional features, type inference, macro, statement as expression…
  - easy C binding
  - todo: i don't really know much more about it..
  
Rust
  - **like C/C++ but safe**, using a specific memory management system, wherein you still have fine control of memory, but apparently it's not as bad as C/C++ (run-time safety, etc.). **no garbage collector**, you *must* learn and use this system to handle the memory yourself (probably like learning Obj-C's reference counting), *"a true systems programming language"*
    - all of that of course comes with the cost of a slower development time
  - performance-oriented, allowing for many kinds of optimizations and implementations (compiles, static-typed)
  - composition > inheritance
  - Go's concurrency/threading features
  - brace-delimited style
  - pop contemporary features: generics, closure, functional features, type inference, macro, statement as expression…  
  - **people seem to really quite like this one**, many new game-frameworks are made with this, and it makes sense, as it has the right features for it
  - people have went crazy making Rust bindings for nearly every C/C++ library out there.., maybe writing C bindings have become easier?
  - Mozilla, and as always, open-source

Odin
  - from the hand-made network
  - like C, not object-oriented, with a belief that *data and procedures should be seperate, and that behaviors shouldn't even exist!*
  - influenced by Go



## others
Go
  - seems to be like a contemporary C, and a good alternative to C++'s much hated development path
  - **at the speed of C :o**
  - used by a ton of huge web companies, thanks to it's built-in concurrency (goroutines), making it very good for web APIs
  - simple, straight-forward, procedural style, but pretty spartan and feature-less, making it far less appealing for hobbyists
  - todo: no memory management?? what? surely i read wrong..
  - this seems to have influenced a lot of languages, especially it's concurrency features
  - Google, but open-source
    
Pony
  - lol, i like this idea, extremely statically typed, so that it's never a question, no concept of memory management



https://www.atatus.com/blog/rust-vs-golang/


# the fastest languages
tier 1 (manual memory management) for crazy people
Rust (borrow-checker)
C++
C
Go (manual?)
Chapel (manual?)
Swift (reference counting)

#tier 2 (garbage collected) for me! :)
Dart

C#
Java

Crystal
Nim
pypy
Lua (LuaJIT)
Haxe (HashLink)


tier 4 (interpreted) *not for games!!*
Ruby - ~5x slower
Lua - ~5-15x slower (not LuaJIT?)
Python - ~10-15x slower

Perl - ~20+ slower


# "server-side", "scripting" languages:
usually have an interpreter so that you can run it ("in run-time") via CLI with single commands or scripts, as opposed to having to be compiled *and then* ran ...although, nowadays, this dividing line is quite blurry

see https://stackoverflow.com/questions/17253545/scripting-language-vs-programming-language


## the standards
**haxe**
  - **my favorite** language
  - compiled, static-typed
  - runs on front-end and back-end
  - can interop with C/C++
    - can even automatically generate the bindings!
  - **can compile to any language, including C**
    - but beware, this route would probably make it hard to debug
  - **compiles to bytecode then is run through a very fast VM (Neko, HashLink), like Lua**
  - made by one French guy

ruby
  - like Haxe, seems to have a nice cult community of hackers :)
    - this alone makes it much more appealing to me than the other pop general languages
  - also like Haxe, whereas Haxe devs tend to write object-oriented programs, Ruby in itself *is* object-oriented
  - quite slow :(
    - also can be compiled via C-ruby?
  - made by one Japanese guy
    
python
  - most popular and most loved
  - can interop with C/C++
  - dynamic
  - very slow
    - also can be compiled via C-Python?, down to bytecode, run in a VM like Java, and it'll still be 2x slower than ruby!
  - **pypy**, is an especially fast implmentation putting it at Lua speeds
  
java
  - similar to C++ but without memory management (pointers)
  - similar to Haxe in that it is converted down to bytecode and then run through a VM (JVM)
  
 
## not really server-side, but it's possible to build web apps!
C#
  - **through ASP.NET Core, can build cross-platform apps (including web** via WebAssembly)
    - this makes it a great choice, competing with not just web apps, but Google's Flutter, and even simple game-like apps.
  - Avalonia framework
    - like Flutter, but with C#/.NET/VS :o
  - Uno framework
    - like Flutter, a little different in implementation, more mobile-oriented, including hot-reloading :o
  - for a long time this only worked with Windows servers (IIS), thus making it less popular, but since ASP.NET *Core* in around 2015, it has since then become open-source, cross-platform (along with VS Code!), making MicroSoft look much better to the dev communities than both Google and Apple!
  - the con of this is that you need a solid development environment: the current version of Visual Studio (not VS Code), probably a Windows IIS server(??), and still need to compile the code, build it, then deploy it, making the entire build process far more cumbersome compared to the common server-side langugaes, where you can just go in with a terminal, edit some code, 'n run it all via CLI
  - however, **for big, serious projects, it's worth the powerful language (C#), framework (.NET), and environment (VS), all of which are perhaps considered some of the best**
  - C# also has one of the biggest dev communities
  
dart
  - Google's Haxe
  - used for the cross-platform (including web) Flutter framework
  - i personally don't trust Google in general, as they never work with the dev communities, never update their software, and often abandon their own software, making very strange one-off products
  - is it even open-source!?!?
    
  
# others
kotlin
  - Google replaced java with this for their Android devices
  - i'm guessing it interops/embeds with java
  - i don't know anymore about it..

perl
  - i've always viewed this as a terse, perplexing langauge, like regex
  - seems to have the reputation that only old veteran hackers have ever mastered it
  - embeds/interops with C/C++?
  
scala
  - allows for both object-oriented paradign and functional paradigm, thus making it less popular compared to solely object-oriented languages
  - uses java's VM: JVM, thus making it work seamlessly alongisde java?

javascript
  - an old dynamic front-end rather mundane language that has over time become used for everything because of the abundance of web devs, including server-side
  - through Node.js, Express.js, etc. 'middle-ware" frameworks, it can then be used server-side
  - dynamic typing, retarded manual type checking (===, NaN, etc.)
  - Google's v8 engine compiles javascript into machine code, instead of using the normal interpreter method, thus single-handedly causing this entire mess

PHP
  - perhaps the only thing worse than javascript, and perhaps closest to the horror that is objective-c
  - have you ever seen WordPress?.. :sob:


# resources
https://blog.back4app.com/server-side-programming-languages/
  - a pretty simple and good summary of the popular languages (although, no haxe :( )
  
https://programmingzen.com/10-lesser-known-programming-languages-worth-exploring/
