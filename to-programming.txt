
# programming language elements

see the docs for haxe
  - this covers the basic and many advanced features of most programming languages
  - i will categorize my notes similar to the docs: types, type systems, expressions, features, compiler, etc.
  - https://haxe.org/manual/introduction.html
  
also the language features page
  - this page quickly lists a sub-set of advanced features of haxe
  - https://haxe.org/manual/lf.html
  
see the docs for other languages
  - i personally like how succint and simple haxe's docs are, it helps with memorization, but it's worth seeing other docs. For example, the docs to Rust is like a book!
  - language-specific features are noted in seperate notes for each programming language (ruby.txt for ruby, etc.)


## types

### basic types
bool - 1 bit?
int - 8, 16, 32, 64 bits
float - 8, 16, 32, 64 bits

### advanced types
class (instance)
enum (instance)
anonymous structure
function type
dynamic
abstract
monomorph


## expressions
tell what a program should do


## features


### macros


### compiler metadata
i think the metadata is sent to the compiler to to either conditionally do different stuff or run a macro...

haxe's list of compiler metadata, for example, is exhausting, mostly due to it's multi-target nature
  - https://haxe.org/manual/cr-metadata.html


## compilers
"The Haxe Compiler is typically invoked from command line with several arguments which have to answer two questions:
What should be compiled?
What should the output be?"

generally the answers are a Main class for input, and
a target platform: this could be source code, bytecode, machine code

### compiler flags
haxe's options for compiling, for example, are exhausting, mostly due to it's multi-target nature
  - https://haxe.org/manual/compiler-usage-flags.html

### a build file
usually a standard build file is provided to store the compiler options, for convenience




## standard library:
included in most general programming languages, though can be excluded from embedded scripting languages, for example: Lua and Wren

std lib strucutre from haxe's docs, expanded a few categories:
Standard Library
String
Data Structures
  - Array
  - Vector
  - List
  - GenericStack
  - Map
  - Option(?)
Regular Expressions
Math
Lambda
Template
Reflection
Serialization
Xml
Json
Input/Output
Sys
  - Threading
  - Standard IO Streams
  - Process
x/Remoting
  - replaced by sockets?
Unit Testing
Haxe 3 Compatibility

there's also target-specific stuff.. (todo)





### processes, threads, and fibers
processes
  - run a process--basically a another OS program/executable
  - example api:
    - pID, close, exit code, kill
    - readonly: input stream, output stream, error output stream
      - https://haxe.org/manual/std-input-output-process.html
  
threads
  - like another Main() process
  - generally you don't have control of this
    - "...typically switching between threads is handled by the operating system, a process known as *preemptive scheduling*. Fibers, by contrast, are *cooperatively scheduled*: they must voluntarily yield control, usually at the behest of the programmer."
      - https://thoughtbot.com/blog/meet-fiber-thread-s-cooperative-cousin
  - from the haxe docs:
    - "All spawned threads are treated as daemon threads, meaning that the main thread will not wait for their completion."
    - "Due to threads having access to a shared memory space with all the Haxe variables and objects, it is possible to run into issues due to deadlocks and race conditions. The standard library provides some core synchronization constructs in the sys.thread package."
      - https://haxe.org/manual/std-threading.html

fibers
  - "Fibers are primitives for implementing light weight cooperative concurrency in Ruby. Basically they are a means of creating code blocks that can be paused and resumed, much like threads. The main difference is that they are never preempted and that the scheduling must be done by the programmer and not the VM."
    - from Ruby's docs on Fiber: https://ruby-doc.org/core-2.1.1/Fiber.html







http://www.craftinginterpreters.com/a-map-of-the-territory.html
  - this chapter lays out the all of the concepts about *how programming languages work* very simply and lightly

https://dinghy.xyz/posts/experts-and-beginners/
  - although only a few posts on this site, has very good ideas on making a creative-oriented game framework

https://snowkit.github.io/snow/guide/code.html
  - coding conventions by snowkit (which included the luxe guy)

difference between pointer and reference (in C)
  - https://stackoverflow.com/questions/4995899/difference-between-pointer-and-reference-in-c
    - a very very good answer!
    - basically: reference is like a goto, there is no memory allocated for it
    - pointer is actual data, and has memory allocated for it ("dereferencing" it leads to whatever it's pointing at)
