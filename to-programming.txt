
# programming features
see the docs for haxe
also the language features page
see the docs for other languages



## processes, threads, and fibers
processes
  - run a process--basically a another OS program/executable
  - example api:
    - pID, close, exit code, kill
    - readonly: input stream, output stream, error output stream
      - https://haxe.org/manual/std-input-output-process.html
  
threads
  - like another Main() process
  - generally you don't have control of this
  - from the haxe docs:
    - "All spawned threads are treated as daemon threads, meaning that the main thread will not wait for their completion."
    - "Due to threads having access to a shared memory space with all the Haxe variables and objects, it is possible to run into issues due to deadlocks and race conditions. The standard library provides some core synchronization constructs in the sys.thread package."
      - https://haxe.org/manual/std-threading.html

fibers
  - "Fibers are primitives for implementing light weight cooperative concurrency in Ruby. Basically they are a means of creating code blocks that can be paused and resumed, much like threads. The main difference is that they are never preempted and that the scheduling must be done by the programmer and not the VM."
    - from Ruby's docs on Fiber: https://ruby-doc.org/core-2.1.1/Fiber.html







http://www.craftinginterpreters.com/a-map-of-the-territory.html
  - this chapter lays out the all of the concepts about *how programming languages work* very simply and lightly

https://dinghy.xyz/posts/experts-and-beginners/
  - although only a few posts on this site, has very good ideas on making a creative-oriented game framework

https://snowkit.github.io/snow/guide/code.html
  - coding conventions by snowkit (which included the luxe guy)

difference between pointer and reference (in C)
  - https://stackoverflow.com/questions/4995899/difference-between-pointer-and-reference-in-c
    - a very very good answer!
    - basically: reference is like a goto, there is no memory allocated for it
    - pointer is actual data, and has memory allocated for it ("dereferencing" it leads to whatever it's pointing at)
